#define _CRT_SECURE_NO_WARNINGS 1
//前言:
//前面的 map 和 set 的底层是通过红黑树来实现的,但是红黑树仅仅是实现 map 和 set 的其中的一种方式
//---map 和 set 的另外一种方式是底层为哈希表


//哈希(也叫做散列)------哈希表有的地方也叫做散列表



//一丶 开始介绍
//1.哈希的本质就是找到一个存储或者映射他的位置(例如计数排序中的第一步,统计每个数字出现的次数)
//--也就是说哈希就是要通过某种方式建立两者之间的关系





//二丶 哈希表的形状
//1.比如将 10 15  999 888 400 300  统计这些数字的出现的次数
//ps1:开辟一个数组用来存放这些数出现的次数(数组中每个下标保存的元素最开始都是 0)                      -----这样也叫做除留余数法
//ps2:将这些数字去模上数组的长度,得到的余数就是数组的下标.每得到这个下标之后就将这个下标中保存的数字进行++
//ps3:但是这样会出现一个问题,比如 300,400 都去模 10,余数都是 0,也就会造成下标相同,但是两个数字不一样不能对同一个下标中保存的元素进行++
//---这样的问题就叫做哈希冲突(也叫做哈希碰撞):即不同关键字通过相同哈希数计算出相同的哈希地址
//---把具有不同关键码(上面的数字)而具有相同的哈希地址(得出的余数)的数据元素称为"同义词".    元素还是上面的这些元素








//重点
//二丶 如何解决哈希冲突                 ------常见的两种解决办法:闭散列  开散列
//方法1.闭散列    解决办法:开放定址法
//这种方法也叫做--开放定址法,当发生哈希冲突的时候,如果哈希表未被填满,说明在哈希表中必定还有空位置,那么可以把 key 存放到冲突位置的"下一个空位置中去"
//不同的位置冲突数据会互相影响,相邻位置的冲突会争抢位置,互相影响效率

//1.怎么寻找"下一个"空位置呢?
//ps1:线性探测
//---从发生冲突的位置开始,依次向后探测,直到寻找到下一个空位置开始      ---但是这样可能会造成一种情况,这个元素抢别人的,然后本该这个位置的元素再去抢别的元素的位置,一直这样下去


//ps2:二次探测
#include"15_哈希表的实现_闭散列.h"



void TestHashTable()
{
    HashTable<int, int>ht;
    int arr[] = { 2,12,22,32,42,52,62,72,72 };
    for (auto e : arr)
    {
        ht.insert(make_pair(e, e));
    }

    cout << ht.find(12) << endl;
    ht.erase(12);
    cout << ht.find(12) << endl;
}



void TestHashTable1()
{
    HashTable<string, string,Hash>ht;
    ht.insert(make_pair("sort", "排序"));//也就是说如果插入的是字符串会怎么办    ----会报错,会在取模的地方崩溃,字符串是没有办法取模的
    ht.insert(make_pair("apple", "苹果"));

    //HashStr str1;
    //HashStr str2;

    //cout << str1("apple") << endl;
    //cout << str2("orange") << endl;
    //cout << str2("elppa") << endl;//虽然顺序不同,但是输出的数字是一样的,但是用了BKDR算法之后,就不会冲突了                  //----------此外还有字符串哈希算法
}

int main(void)
{
    cout << "hehe" << endl;
    TestHashTable();
    TestHashTable1();
}




//方法2:开散列      解决办法:拉链法丶哈希桶
//这种方法又叫做链地址法(拉链法/哈希桶),首先对关键码集合用散列函数计算散列地址,具有相同地址的关键码归于同一子集合,每一个子集合称为一个桶,各个桶中的元素通过一个单链表链接起来,各俩链表的头结点存储在哈希表中

//相邻位置冲突,不会再争抢位置,不会互相影响
// 
//
