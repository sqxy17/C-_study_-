//前言:
//前面的 map 和 set 的底层是通过红黑树来实现的,但是红黑树仅仅是实现 map 和 set 的其中的一种方式
//---map 和 set 的另外一种方式是底层为哈希表


//哈希(也叫做散列)------哈希表有的地方也叫做散列表



//一丶 开始介绍
//1.哈希的本质就是找到一个存储或者映射他的位置(例如计数排序中的第一步,统计每个数字出现的次数)
//--也就是说哈希就是要通过某种方式建立两者之间的关系





//二丶 哈希表的形状
//1.比如将 10 15  999 888 400 300  统计这些数字的出现的次数
//ps1:开辟一个数组用来存放这些数出现的次数(数组中每个下标保存的元素最开始都是 0)                      -----这样也叫做除留余数法
//ps2:将这些数字去模上数组的长度,得到的余数就是数组的下标.每得到这个下标之后就将这个下标中保存的数字进行++
//ps3:但是这样会出现一个问题,比如 300,400 都去模 10,余数都是 0,也就会造成下标相同,但是两个数字不一样不能对同一个下标中保存的元素进行++
//---这样的问题就叫做哈希冲突(也叫做哈希碰撞):即不同关键字通过相同哈希数计算出相同的哈希地址
//---把具有不同关键码(上面的数字)而具有相同的哈希地址(得出的余数)的数据元素称为"同义词".    元素还是上面的这些元素








//重点
//二丶 如何解决哈希冲突                 ------常见的两种解决办法:闭散列  开散列
//方法1.闭散列    ---开放定址法
//这种方法也叫做--开放定址法,当发生哈希冲突的时候,如果哈希表未被填满,说明在哈希表中必定还有空位置,那么可以把 key 存放到冲突位置的"下一个空位置中去"

//1.怎么寻找"下一个"空位置呢?
//ps1:线性探测
//---从发生冲突的位置开始,依次向后探测,直到寻找到下一个空位置开始      ---但是这样可能会造成一种情况,这个元素抢别人的,然后本该这个位置的元素再去抢别的元素的位置,一直这样下去


//ps2:二次探测
#include"15_哈希表的实现.h"



void TestHashTable()
{
    HashTable<int,int>ht;
    int arr[]={2,12,22,32};
    for(auto e:arr)
    {
        ht.insert(make_pair(e,e));
    }
}
int main(void)
{
    cout<<"hehe"<<endl;
    TestHashTable();
}




//方法2:开散列
//这种方法又叫做链地址法(开链法),首先对关键码集合用散列函数计算散列地址,具有相同地址的关键码归于同一子集合,每一个子集合称为一个桶,各个桶中的元素通过一个单链表链接起来,各俩链表的头结点存储在哈希表中
